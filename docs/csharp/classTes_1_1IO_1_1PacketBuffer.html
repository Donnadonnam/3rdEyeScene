<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>3rd Eye Scene C#: Tes::IO::PacketBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">3rd Eye Scene C#</div>
   <div id="projectbrief">3rd Eye Scene C# documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classTes_1_1IO_1_1PacketBuffer.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#properties">Properties</a>  </div>
  <div class="headertitle">
<div class="title">Tes::IO::PacketBuffer Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Tes::IO::PacketBuffer" -->
<p>The <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html" title="The Tes.IO.PacketBuffer is used to collate incoming network data and extract a Tes.IO.PacketHeader and payload.">Tes.IO.PacketBuffer</a> is used to collate incoming network data and extract a <a class="el" href="structTes_1_1IO_1_1PacketHeader.html" title="The header for an incoming 3ES data packet.">Tes.IO.PacketHeader</a> and payload.  
 <a href="classTes_1_1IO_1_1PacketBuffer.html#details">More...</a></p>

<p><a href="classTes_1_1IO_1_1PacketBuffer-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6359621cea5a052c4ea0806e37167534"></a><!-- doxytag: member="Tes::IO::PacketBuffer::PacketBuffer" ref="a6359621cea5a052c4ea0806e37167534" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a6359621cea5a052c4ea0806e37167534">PacketBuffer</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a5640b2621d8542d643c8c514ae6f3492">PacketBuffer</a> (int initialBufferSize, bool useBufferPool=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a packet with the given initial buffer size.  <a href="#a5640b2621d8542d643c8c514ae6f3492"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#ace630ed2a50fda4951cfad2980b120df">Dispose</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal buffer pack to the T:ArrayPool when using a rented buffer.  <a href="#ace630ed2a50fda4951cfad2980b120df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3f0e610f8c5396519f21bc84fe25868"></a><!-- doxytag: member="Tes::IO::PacketBuffer::Reset" ref="ab3f0e610f8c5396519f21bc84fe25868" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#ab3f0e610f8c5396519f21bc84fe25868">Reset</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Full reset the packet. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#ab5f9f378e3bb236ecc2107ef2c495a9d">Reset</a> (ushort routingId, ushort messageId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the packet while maintaining the current header with a new <em>routingId</em>   <a href="#ab5f9f378e3bb236ecc2107ef2c495a9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a4f7dda99c241c5231841157c289d8a29">WriteHeader</a> (<a class="el" href="structTes_1_1IO_1_1PacketHeader.html">PacketHeader</a> header)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the buffer and writes a new header to the packet.  <a href="#a4f7dda99c241c5231841157c289d8a29"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#af84aad621ab2e6fb0c93aae43a0212ab">WriteBytes</a> (byte[] bytes, bool toNetworkEndian, int offset=0, int length=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data into the packet.  <a href="#af84aad621ab2e6fb0c93aae43a0212ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a09c5f5cf6f5d7806879af3898ef6a8ca">FinalisePacket</a> (bool addCrc=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalise an output packet.  <a href="#a09c5f5cf6f5d7806879af3898ef6a8ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a09d4725d358b2fc2f379d460822dbe35">ExportTo</a> (BinaryWriter writer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports the packet contents to the given </p>
<div class="fragment"><pre class="fragment">BinaryWriter
</pre></div><p>.  <a href="#a09d4725d358b2fc2f379d460822dbe35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a89221d1d4096f58c110090f3191c9d69">ExportTo</a> (Stream stream)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports the packet contents to the given </p>
<div class="fragment"><pre class="fragment">Stream
</pre></div><p>.  <a href="#a89221d1d4096f58c110090f3191c9d69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ushort&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a6ef384a5274bc5fa0cc60e2e45f2aa07">PeekUInt16</a> (int offset)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek at two bytes in the message content.  <a href="#a6ef384a5274bc5fa0cc60e2e45f2aa07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#ad67e441209c35b679e4f2bb47e893487">PeekUInt32</a> (int offset)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek at four bytes in the message content.  <a href="#ad67e441209c35b679e4f2bb47e893487"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ulong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#acfc212bfbe602051660e228cbdd1ad18">PeekUInt64</a> (int offset)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek at four bytes in the message content.  <a href="#acfc212bfbe602051660e228cbdd1ad18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a0d2aa50896c4a29e3f904b446c78a60c">PeekBytes</a> (int offset, byte[] bytes, int byteCount)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek at a number of bytes in the message content.  <a href="#a0d2aa50896c4a29e3f904b446c78a60c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Stream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#ae9ce7b41506178a2aa4f1b3ec38e19ff">CreateReadStream</a> (bool skipHeader)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates a memory stream which reads the bytes in this packet buffer.  <a href="#ae9ce7b41506178a2aa4f1b3ec38e19ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a351391d5e39905cae270f095966d165c">Append</a> (byte[] bytes, int available)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends data to the internal buffer to complete the current message.  <a href="#a351391d5e39905cae270f095966d165c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a169244f42d1a6997ac9c3cb87c83b528">Append</a> (Stream stream, int available)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An overload supporting reading bytes from a </p>
<div class="fragment"><pre class="fragment">Stream
</pre></div><p> instead of a byte array.  <a href="#a169244f42d1a6997ac9c3cb87c83b528"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html">PacketBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#ad81979659ab2d23d7e42273c690debc8">PopPacket</a> (out bool crcOk)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops the next available packet from the internal buffer.  <a href="#ad81979659ab2d23d7e42273c690debc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a47c388a8ac29a723ad6cad704f1e76de">Emplace</a> (byte[] bytes, int available)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplace bytes within the buffer, returning true if this completes the packet.  <a href="#a47c388a8ac29a723ad6cad704f1e76de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a0952c4e9dc693efd378b27da1d772ca4">Emplace</a> (byte[] bytes, int offset, int length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplace bytes within the buffer, returning true if this completes the packet.  <a href="#a0952c4e9dc693efd378b27da1d772ca4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a5db9959e0f8548940e25136fb5119aaf">Emplace</a> (Stream stream, int available)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplace bytes from a stream.  <a href="#a5db9959e0f8548940e25136fb5119aaf"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="properties"></a>
Properties</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21d015b80dae7e5fd267b7072ad0f549"></a><!-- doxytag: member="Tes::IO::PacketBuffer::Status" ref="a21d015b80dae7e5fd267b7072ad0f549" args="" -->
<a class="el" href="namespaceTes_1_1IO.html#a7b14474ee0d676aa02e4d3672b26a9ba">PacketBufferStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a21d015b80dae7e5fd267b7072ad0f549">Status</a><code> [get, set]</code></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Packet status. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a96e3fcc6f3c04d9080e35f7d6ba0f6c9">ValidHeader</a><code> [get, set]</code></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the header valid?  <a href="#a96e3fcc6f3c04d9080e35f7d6ba0f6c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTes_1_1IO_1_1PacketHeader.html">PacketHeader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#acc28be82f3d55d256dc49e489fd2d78a">Header</a><code> [get]</code></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The current packet header.  <a href="#acc28be82f3d55d256dc49e489fd2d78a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2787687dd9f8a9517cd07d9b67d2b339"></a><!-- doxytag: member="Tes::IO::PacketBuffer::Count" ref="a2787687dd9f8a9517cd07d9b67d2b339" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a2787687dd9f8a9517cd07d9b67d2b339">Count</a><code> [get]</code></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of byte available in the buffer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte[]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#ab871de4b8ea2ded5d16f0a36ef690067">Data</a><code> [get]</code></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the internal buffer bytes.  <a href="#ab871de4b8ea2ded5d16f0a36ef690067"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66883875a3e28e8735cbbd30423c7ec5"></a><!-- doxytag: member="Tes::IO::PacketBuffer::Cursor" ref="a66883875a3e28e8735cbbd30423c7ec5" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a66883875a3e28e8735cbbd30423c7ec5">Cursor</a><code> [get]</code></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the start of the next packet in the buffer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#ad15aed8fcf372c82acf581688a3d9ad7">DroppedByteCount</a><code> [get, set]</code></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks the number of dropped bytes.  <a href="#ad15aed8fcf372c82acf581688a3d9ad7"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html" title="The Tes.IO.PacketBuffer is used to collate incoming network data and extract a Tes.IO.PacketHeader and payload.">Tes.IO.PacketBuffer</a> is used to collate incoming network data and extract a <a class="el" href="structTes_1_1IO_1_1PacketHeader.html" title="The header for an incoming 3ES data packet.">Tes.IO.PacketHeader</a> and payload. </p>
<p>A </p>
<div class="fragment"><pre class="fragment"><a class="code" href="classTes_1_1IO_1_1PacketBuffer.html#a6359621cea5a052c4ea0806e37167534" title="Default constructor.">PacketBuffer</a>
</pre></div><p> can be used in two ways: input and output</p>
<p>An input packet is used to collate data coming from a network or file stream. Bytes are read from the stream and added to the </p>
<div class="fragment"><pre class="fragment"><a class="code" href="classTes_1_1IO_1_1PacketBuffer.html#a6359621cea5a052c4ea0806e37167534" title="Default constructor.">PacketBuffer</a>
</pre></div><p> by calling <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a351391d5e39905cae270f095966d165c" title="Appends data to the internal buffer to complete the current message.">Append(byte[], int)</a>. Individual messages are extracted using <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#ad81979659ab2d23d7e42273c690debc8" title="Pops the next available packet from the internal buffer.">PopPacket(out bool)</a>, which creates a new <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html" title="The Tes.IO.PacketBuffer is used to collate incoming network data and extract a Tes.IO.PacketHeader and payload.">PacketBuffer</a> containing data for a single message. Data are read from this message by obtaining a </p>
<div class="fragment"><pre class="fragment">Stream
</pre></div><p> from <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#ae9ce7b41506178a2aa4f1b3ec38e19ff" title="Instantiates a memory stream which reads the bytes in this packet buffer.">CreateReadStream(bool)</a>. This is summarised below:</p>
<ul>
<li>
Add data by calling <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a351391d5e39905cae270f095966d165c" title="Appends data to the internal buffer to complete the current message.">Append(byte[], int)</a> until it returns <div class="fragment"><pre class="fragment"><span class="keyword">true</span>
</pre></div>. </li>
<li>
Extract messages by calling <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#ad81979659ab2d23d7e42273c690debc8" title="Pops the next available packet from the internal buffer.">PopPacket(out bool)</a> </li>
<li>
Read from extracted messages by creating a stream using <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#ae9ce7b41506178a2aa4f1b3ec38e19ff" title="Instantiates a memory stream which reads the bytes in this packet buffer.">CreateReadStream(bool)</a> </li>
</ul>
<p>Output packets are used to generate content for writing to a network or file stream. An output packet first requires a <a class="el" href="structTes_1_1IO_1_1PacketHeader.html" title="The header for an incoming 3ES data packet.">PacketHeader</a>, which is added to the buffer via <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a4f7dda99c241c5231841157c289d8a29" title="Resets the buffer and writes a new header to the packet.">WriteHeader(PacketHeader)</a>. Message data are then written to the buffer by calling <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#af84aad621ab2e6fb0c93aae43a0212ab" title="Write data into the packet.">WriteBytes(byte[], bool, int, int)</a>. Note that data should only be added to the buffer in network byte order (Big Endian). This conversion must occur before calling <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#af84aad621ab2e6fb0c93aae43a0212ab" title="Write data into the packet.">WriteBytes(byte[], bool, int, int)</a>.</p>
<p>Once all data are written, the packet is finalised calling <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a09c5f5cf6f5d7806879af3898ef6a8ca" title="Finalise an output packet.">FinalisePacket(bool)</a> and may be exported by calling one of the export methods: <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a09d4725d358b2fc2f379d460822dbe35" title="Exports the packet contents to the given BinaryWriter.">ExportTo(BinaryWriter)</a>. Once exported a </p>
<div class="fragment"><pre class="fragment"><a class="code" href="classTes_1_1IO_1_1PacketBuffer.html#a6359621cea5a052c4ea0806e37167534" title="Default constructor.">PacketBuffer</a>
</pre></div><p> may be reused by calling <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#ab3f0e610f8c5396519f21bc84fe25868" title="Full reset the packet.">Reset()</a> and starting the process from the beginning. Alternatively, the existing header may be preserved by calling <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#ab5f9f378e3bb236ecc2107ef2c495a9d" title="Reset the packet while maintaining the current header with a new routingId ">Reset(ushort, ushort)</a> and updating only the <a class="el" href="structTes_1_1IO_1_1PacketHeader.html#a0d24ed9c3ffb3f4060b2934670e8b5c2" title="Identifies the main packet receiver.">PacketHeader.RoutingID</a>.</p>
<p>The output process is summarised below:</p>
<ul>
<li>
Create and write a new header to the packet using <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a4f7dda99c241c5231841157c289d8a29" title="Resets the buffer and writes a new header to the packet.">WriteHeader(PacketHeader)</a> </li>
<li>
Write message data in network byte order using <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#af84aad621ab2e6fb0c93aae43a0212ab" title="Write data into the packet.">WriteBytes(byte[], bool, int, int)</a> </li>
<li>
Finalise the packet size and CRC using <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a09c5f5cf6f5d7806879af3898ef6a8ca" title="Finalise an output packet.">FinalisePacket(bool)</a> </li>
<li>
Export the packet using <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a09d4725d358b2fc2f379d460822dbe35" title="Exports the packet contents to the given BinaryWriter.">ExportTo(BinaryWriter)</a> </li>
<li>
Optionally reset and reuse the packet with <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#ab5f9f378e3bb236ecc2107ef2c495a9d" title="Reset the packet while maintaining the current header with a new routingId ">Reset(ushort, ushort)</a> </li>
</ul>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5640b2621d8542d643c8c514ae6f3492"></a><!-- doxytag: member="Tes::IO::PacketBuffer::PacketBuffer" ref="a5640b2621d8542d643c8c514ae6f3492" args="(int initialBufferSize, bool useBufferPool=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tes::IO::PacketBuffer::PacketBuffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>initialBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useBufferPool</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a packet with the given initial buffer size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">initialBufferSize</td><td>The initial buffer size (bytes)</td></tr>
    <tr><td class="paramname">useBufferPool</td><td>Allow the use of the T:ArrayPool?</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a351391d5e39905cae270f095966d165c"></a><!-- doxytag: member="Tes::IO::PacketBuffer::Append" ref="a351391d5e39905cae270f095966d165c" args="(byte[] bytes, int available)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tes::IO::PacketBuffer::Append </td>
          <td>(</td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>available</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Appends data to the internal buffer to complete the current message. </p>
<p>Returns a <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html" title="The Tes.IO.PacketBuffer is used to collate incoming network data and extract a Tes.IO.PacketHeader and payload.">PacketBuffer</a> with a completed message if <em>bytes</em>  completes the current message.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>The data stream to append.</td></tr>
    <tr><td class="paramname">available</td><td>The number of bytes from <em>bytes</em>  to append. This allows the given buffer to be larger than the available data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if there is a completed packet available.</dd></dl>
<p>As data bytes are appended, the buffer code searches for a valid header, consuming all bytes until a valid header is found - i.e., bytes before the valid header are lost.</p>
<p>Once a valid header is found, </p>
<div class="fragment"><pre class="fragment"><a class="code" href="classTes_1_1IO_1_1PacketBuffer.html#a351391d5e39905cae270f095966d165c" title="Appends data to the internal buffer to complete the current message.">Append</a>()
</pre></div><p> waits for sufficient bytes to complete the packet as specified in the validated header. At this point </p>
<div class="fragment"><pre class="fragment"><a class="code" href="classTes_1_1IO_1_1PacketBuffer.html#a351391d5e39905cae270f095966d165c" title="Appends data to the internal buffer to complete the current message.">Append</a>()
</pre></div><p> returns </p>
<div class="fragment"><pre class="fragment"><span class="keyword">true</span>
</pre></div><p>. Available packets may be extracted by calling <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#ad81979659ab2d23d7e42273c690debc8" title="Pops the next available packet from the internal buffer.">PopPacket(out bool)</a> until that method returns null.</p>
<p>Calling </p>
<div class="fragment"><pre class="fragment"><a class="code" href="classTes_1_1IO_1_1PacketBuffer.html#a351391d5e39905cae270f095966d165c" title="Appends data to the internal buffer to complete the current message.">Append</a>()
</pre></div><p> will change the <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a21d015b80dae7e5fd267b7072ad0f549" title="Packet status.">PacketBuffer.Status</a> as follows: </p>
<table class="doxtable">
<tr>
<th>Status</th><th>Conditions </th></tr>
<tr>
<td><div class="fragment"><pre class="fragment">Empty
</pre></div> </td><td>The append call did not add any data, or an invalid header has been consumed leaving the buffer empty.   </td></tr>
<tr>
<td><div class="fragment"><pre class="fragment">Collating
</pre></div> </td><td>Bytes have been appended, but no complete packet is available yet. The header may be valid: check <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a96e3fcc6f3c04d9080e35f7d6ba0f6c9" title="Is the header valid?">ValidHeader</a>   </td></tr>
<tr>
<td><div class="fragment"><pre class="fragment">Available
</pre></div> </td><td>A header has been validated and sufficient bytes are present to extract a packet. Call <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#ad81979659ab2d23d7e42273c690debc8" title="Pops the next available packet from the internal buffer.">PopPacket(out bool)</a>.   </td></tr>
</table>
<p>" </p>

</div>
</div>
<a class="anchor" id="a169244f42d1a6997ac9c3cb87c83b528"></a><!-- doxytag: member="Tes::IO::PacketBuffer::Append" ref="a169244f42d1a6997ac9c3cb87c83b528" args="(Stream stream, int available)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tes::IO::PacketBuffer::Append </td>
          <td>(</td>
          <td class="paramtype">Stream&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>available</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An overload supporting reading bytes from a </p>
<div class="fragment"><pre class="fragment">Stream
</pre></div><p> instead of a byte array. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to read from.</td></tr>
    <tr><td class="paramname">available</td><td>The number of bytes available to read from the stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<p>See <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a351391d5e39905cae270f095966d165c" title="Appends data to the internal buffer to complete the current message.">Append(byte[], int)</a>. </p>

</div>
</div>
<a class="anchor" id="ae9ce7b41506178a2aa4f1b3ec38e19ff"></a><!-- doxytag: member="Tes::IO::PacketBuffer::CreateReadStream" ref="ae9ce7b41506178a2aa4f1b3ec38e19ff" args="(bool skipHeader)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stream Tes::IO::PacketBuffer::CreateReadStream </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipHeader</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Instantiates a memory stream which reads the bytes in this packet buffer. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The read only memory stream.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">skipHeader</td><td>True to skip the header bytes, moving on to the payload. Includes respecting the payload offset.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace630ed2a50fda4951cfad2980b120df"></a><!-- doxytag: member="Tes::IO::PacketBuffer::Dispose" ref="ace630ed2a50fda4951cfad2980b120df" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tes::IO::PacketBuffer::Dispose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the internal buffer pack to the T:ArrayPool when using a rented buffer. </p>
<p>Call <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#ace630ed2a50fda4951cfad2980b120df" title="Returns the internal buffer pack to the T:ArrayPool when using a rented buffer.">Dispose</a> when you are finished using the T:Tes.IO.PacketBuffer. The <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#ace630ed2a50fda4951cfad2980b120df" title="Returns the internal buffer pack to the T:ArrayPool when using a rented buffer.">Dispose</a> method leaves the T:Tes.IO.PacketBuffer in an unusable state. After calling <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#ace630ed2a50fda4951cfad2980b120df" title="Returns the internal buffer pack to the T:ArrayPool when using a rented buffer.">Dispose</a>, you must release all references to the T:Tes.IO.PacketBuffer so the garbage collector can reclaim the memory that the T:Tes.IO.PacketBuffer was occupying. </p>

</div>
</div>
<a class="anchor" id="a47c388a8ac29a723ad6cad704f1e76de"></a><!-- doxytag: member="Tes::IO::PacketBuffer::Emplace" ref="a47c388a8ac29a723ad6cad704f1e76de" args="(byte[] bytes, int available)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Tes::IO::PacketBuffer::Emplace </td>
          <td>(</td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>available</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Emplace bytes within the buffer, returning true if this completes the packet. </p>
<p>This is equivalent to <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a351391d5e39905cae270f095966d165c" title="Appends data to the internal buffer to complete the current message.">Append(byte[], int)</a>, except this object represents the completed packet.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>The data stream to append.</td></tr>
    <tr><td class="paramname">available</td><td>The number of bytes from <em>bytes</em>  to append. This allows the given buffer to be larger than the available data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes added from <em>bytes</em> .</dd></dl>

</div>
</div>
<a class="anchor" id="a0952c4e9dc693efd378b27da1d772ca4"></a><!-- doxytag: member="Tes::IO::PacketBuffer::Emplace" ref="a0952c4e9dc693efd378b27da1d772ca4" args="(byte[] bytes, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Tes::IO::PacketBuffer::Emplace </td>
          <td>(</td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Emplace bytes within the buffer, returning true if this completes the packet. </p>
<p>This is equivalent to <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a351391d5e39905cae270f095966d165c" title="Appends data to the internal buffer to complete the current message.">Append(byte[], int)</a>, except this object represents the completed packet.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>The data stream to append.</td></tr>
    <tr><td class="paramname">offset</td><td>Byte offset into <em>bytes</em>  to start reading from.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes from <em>bytes</em>  to append. This allows the given buffer to be larger than the available data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes added from <em>bytes</em> .</dd></dl>

</div>
</div>
<a class="anchor" id="a5db9959e0f8548940e25136fb5119aaf"></a><!-- doxytag: member="Tes::IO::PacketBuffer::Emplace" ref="a5db9959e0f8548940e25136fb5119aaf" args="(Stream stream, int available)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Tes::IO::PacketBuffer::Emplace </td>
          <td>(</td>
          <td class="paramtype">Stream&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>available</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Emplace bytes from a stream. </p>
<p>This is equivalent to <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a47c388a8ac29a723ad6cad704f1e76de" title="Emplace bytes within the buffer, returning true if this completes the packet.">Emplace(byte[], int)</a> except for the data source.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to read bytes from.</td></tr>
    <tr><td class="paramname">available</td><td>The number of bytes to read from <em>stream</em> .</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes added from <em>stream</em> .</dd></dl>

</div>
</div>
<a class="anchor" id="a09d4725d358b2fc2f379d460822dbe35"></a><!-- doxytag: member="Tes::IO::PacketBuffer::ExportTo" ref="a09d4725d358b2fc2f379d460822dbe35" args="(BinaryWriter writer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Tes::IO::PacketBuffer::ExportTo </td>
          <td>(</td>
          <td class="paramtype">BinaryWriter&#160;</td>
          <td class="paramname"><em>writer</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Exports the packet contents to the given </p>
<div class="fragment"><pre class="fragment">BinaryWriter
</pre></div><p>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">writer</td><td>The <div class="fragment"><pre class="fragment">BinaryWriter
</pre></div> to export available bytes to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes written</dd></dl>
<p>Export does not validate the packet status, exporting available bytes as is.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classTes_1_1IO_1_1InvalidPacketStatusException.html" title="Exception thrown when a PacketBuffer is in an invalid state for the current operation.">InvalidPacketStatusException</a></td><td>Thrown when the status is not PacketBufferStatus.Complete.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a89221d1d4096f58c110090f3191c9d69"></a><!-- doxytag: member="Tes::IO::PacketBuffer::ExportTo" ref="a89221d1d4096f58c110090f3191c9d69" args="(Stream stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Tes::IO::PacketBuffer::ExportTo </td>
          <td>(</td>
          <td class="paramtype">Stream&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Exports the packet contents to the given </p>
<div class="fragment"><pre class="fragment">Stream
</pre></div><p>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The <div class="fragment"><pre class="fragment">Stream
</pre></div> to export available bytes to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes written</dd></dl>
<p>Export does not validate the packet status, exporting available bytes as is.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classTes_1_1IO_1_1InvalidPacketStatusException.html" title="Exception thrown when a PacketBuffer is in an invalid state for the current operation.">InvalidPacketStatusException</a></td><td>Thrown when the status is not PacketBufferStatus.Complete.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09c5f5cf6f5d7806879af3898ef6a8ca"></a><!-- doxytag: member="Tes::IO::PacketBuffer::FinalisePacket" ref="a09c5f5cf6f5d7806879af3898ef6a8ca" args="(bool addCrc=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tes::IO::PacketBuffer::FinalisePacket </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addCrc</em> = <code>true</code></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finalise an output packet. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">addCrc</td><td>True to calculate and add the CRC.</td></tr>
  </table>
  </dd>
</dl>
<p>Finalises an output packet by updating the packet size, calculating the CRC and writing the CRC to the buffer. The buffer is ready for <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a09d4725d358b2fc2f379d460822dbe35" title="Exports the packet contents to the given BinaryWriter.">ExportTo(BinaryWriter)</a> </p>

</div>
</div>
<a class="anchor" id="a0d2aa50896c4a29e3f904b446c78a60c"></a><!-- doxytag: member="Tes::IO::PacketBuffer::PeekBytes" ref="a0d2aa50896c4a29e3f904b446c78a60c" args="(int offset, byte[] bytes, int byteCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tes::IO::PacketBuffer::PeekBytes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Peek at a number of bytes in the message content. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Offset from the packet start to peek at.</td></tr>
    <tr><td class="paramname">bytes</td><td>The byte stream to write to.</td></tr>
    <tr><td class="paramname">byteCount</td><td>The number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True when <em>offset</em>  the <code>byteCount</code> are both in range.</dd></dl>
<p>The read bytes are left in network Endian. </p>

</div>
</div>
<a class="anchor" id="a6ef384a5274bc5fa0cc60e2e45f2aa07"></a><!-- doxytag: member="Tes::IO::PacketBuffer::PeekUInt16" ref="a6ef384a5274bc5fa0cc60e2e45f2aa07" args="(int offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ushort Tes::IO::PacketBuffer::PeekUInt16 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Peek at two bytes in the message content. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Offset from the packet start to peek at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The peeked value or zero when <em>offset</em>  is out of range.</dd></dl>
<p>Two bytes are read from the message at the given offset and converted from network to local Endian. </p>

</div>
</div>
<a class="anchor" id="ad67e441209c35b679e4f2bb47e893487"></a><!-- doxytag: member="Tes::IO::PacketBuffer::PeekUInt32" ref="ad67e441209c35b679e4f2bb47e893487" args="(int offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint Tes::IO::PacketBuffer::PeekUInt32 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Peek at four bytes in the message content. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Offset from the packet start to peek at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The peeked value or zero when <em>offset</em>  is out of range.</dd></dl>
<p>Four bytes are read from the message at the given offset and converted from network to local Endian. </p>

</div>
</div>
<a class="anchor" id="acfc212bfbe602051660e228cbdd1ad18"></a><!-- doxytag: member="Tes::IO::PacketBuffer::PeekUInt64" ref="acfc212bfbe602051660e228cbdd1ad18" args="(int offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulong Tes::IO::PacketBuffer::PeekUInt64 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Peek at four bytes in the message content. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Offset from the packet start to peek at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The peeked value or zero when <em>offset</em>  is out of range.</dd></dl>
<p>Four bytes are read from the message at the given offset and converted from network to local Endian. </p>

</div>
</div>
<a class="anchor" id="ad81979659ab2d23d7e42273c690debc8"></a><!-- doxytag: member="Tes::IO::PacketBuffer::PopPacket" ref="ad81979659ab2d23d7e42273c690debc8" args="(out bool crcOk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html">PacketBuffer</a> Tes::IO::PacketBuffer::PopPacket </td>
          <td>(</td>
          <td class="paramtype">out bool&#160;</td>
          <td class="paramname"><em>crcOk</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pops the next available packet from the internal buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">crcOk</td><td>Exposes the results of the CRC check. Always true when a valid packet is returned. Also true when no packet is available. Only false when a completed packet is available, but the CRC fails.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The next available packet or null if not available or the CRC check fails.</dd></dl>
<p>A </p>
<div class="fragment"><pre class="fragment"><a class="code" href="classTes_1_1IO_1_1PacketBuffer.html#a6359621cea5a052c4ea0806e37167534" title="Default constructor.">PacketBuffer</a>
</pre></div><p> accumulating packets using <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a351391d5e39905cae270f095966d165c" title="Appends data to the internal buffer to complete the current message.">Append(byte[], int)</a> may contain at least one completed packet. This method is used to extract each packet as a self contained </p>
<div class="fragment"><pre class="fragment"><a class="code" href="classTes_1_1IO_1_1PacketBuffer.html#a6359621cea5a052c4ea0806e37167534" title="Default constructor.">PacketBuffer</a>
</pre></div><p>. When completed packets are available, this method returns each available completed packet as a single, self contained item.</p>
<p>The bytes making up the completed packet are removed from this packet buffer while excess bytes are preserved.</p>
<p>A null packet buffer may also be returned when there is enough data for a packet, but the CRC check fails. This case is detected when null is returned as <em>crcOk</em>  is </p>
<div class="fragment"><pre class="fragment"><span class="keyword">false</span>
</pre></div><p> (failed CRC) as opposed to null returned and <em>crcOk</em>  </p>
<div class="fragment"><pre class="fragment"><span class="keyword">true</span>
</pre></div><p> (no packet). </p>

</div>
</div>
<a class="anchor" id="ab5f9f378e3bb236ecc2107ef2c495a9d"></a><!-- doxytag: member="Tes::IO::PacketBuffer::Reset" ref="ab5f9f378e3bb236ecc2107ef2c495a9d" args="(ushort routingId, ushort messageId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tes::IO::PacketBuffer::Reset </td>
          <td>(</td>
          <td class="paramtype">ushort&#160;</td>
          <td class="paramname"><em>routingId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ushort&#160;</td>
          <td class="paramname"><em>messageId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset the packet while maintaining the current header with a new <em>routingId</em>  </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">routingId</td><td>The routing ID for the header.</td></tr>
    <tr><td class="paramname">messageId</td><td>The message ID for the router to handle.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af84aad621ab2e6fb0c93aae43a0212ab"></a><!-- doxytag: member="Tes::IO::PacketBuffer::WriteBytes" ref="af84aad621ab2e6fb0c93aae43a0212ab" args="(byte[] bytes, bool toNetworkEndian, int offset=0, int length=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tes::IO::PacketBuffer::WriteBytes </td>
          <td>(</td>
          <td class="paramtype">byte[]&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>toNetworkEndian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write data into the packet. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Data to write. Bytes are converted to network Endian (Big Endian)</td></tr>
    <tr><td class="paramname">toNetworkEndian</td><td>When <div class="fragment"><pre class="fragment"><span class="keyword">true</span>
</pre></div>, <em>bytes</em>  are converted to network Endian (Big Endian), otherwise <em>bytes</em>  are written as is.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset from the start of <em>bytes</em>  to start writing from.</td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes to write. Zero for all bytes from <em>offset</em>  to the end of <em>bytes</em> .</td></tr>
  </table>
  </dd>
</dl>
<p>The buffer size is increased if required. </p>

</div>
</div>
<a class="anchor" id="a4f7dda99c241c5231841157c289d8a29"></a><!-- doxytag: member="Tes::IO::PacketBuffer::WriteHeader" ref="a4f7dda99c241c5231841157c289d8a29" args="(PacketHeader header)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tes::IO::PacketBuffer::WriteHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTes_1_1IO_1_1PacketHeader.html">PacketHeader</a>&#160;</td>
          <td class="paramname"><em>header</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets the buffer and writes a new header to the packet. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">header</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Intended for use in packet export only.</p>
<p>The <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#acc28be82f3d55d256dc49e489fd2d78a" title="The current packet header.">Header</a> is set to match <em>header</em> , <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a96e3fcc6f3c04d9080e35f7d6ba0f6c9" title="Is the header valid?">ValidHeader</a> becomes </p>
<div class="fragment"><pre class="fragment"><span class="keyword">true</span>
</pre></div><p> and the status changes to PacketBufferStatus.Collating. The given <em>header</em>  is immediately written to the packet buffer.</p>
<p>Message data may then be written to the buffer and the packet completed by calling <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a09c5f5cf6f5d7806879af3898ef6a8ca" title="Finalise an output packet.">FinalisePacket(bool)</a>, which fixes the packet size. </p>

</div>
</div>
<hr/><h2>Property Documentation</h2>
<a class="anchor" id="ab871de4b8ea2ded5d16f0a36ef690067"></a><!-- doxytag: member="Tes::IO::PacketBuffer::Data" ref="ab871de4b8ea2ded5d16f0a36ef690067" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte [] Tes::IO::PacketBuffer::Data<code> [get]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct access to the internal buffer bytes. </p>
<p>Intended to aid in serialisation of completed packets. For example: </p>
<div class="fragment"><pre class="fragment">          writer.Send(packet.Data, packet.Cursor, packet.Count)
</pre></div><p>Use with care. </p>

</div>
</div>
<a class="anchor" id="ad15aed8fcf372c82acf581688a3d9ad7"></a><!-- doxytag: member="Tes::IO::PacketBuffer::DroppedByteCount" ref="ad15aed8fcf372c82acf581688a3d9ad7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Tes::IO::PacketBuffer::DroppedByteCount<code> [get, set]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tracks the number of dropped bytes. </p>
<p>This value is adjusted when the header marker cannot be found an identifies how many bytes are removed from the packet before finding valid header marker. The value continually accumulates but may be cleared by users of the packet buffer. </p>

</div>
</div>
<a class="anchor" id="acc28be82f3d55d256dc49e489fd2d78a"></a><!-- doxytag: member="Tes::IO::PacketBuffer::Header" ref="acc28be82f3d55d256dc49e489fd2d78a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTes_1_1IO_1_1PacketHeader.html">PacketHeader</a> Tes::IO::PacketBuffer::Header<code> [get]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The current packet header. </p>
<p>Only relevant when <a class="el" href="classTes_1_1IO_1_1PacketBuffer.html#a96e3fcc6f3c04d9080e35f7d6ba0f6c9" title="Is the header valid?">ValidHeader</a> is <code>true</code>. </p>

</div>
</div>
<a class="anchor" id="a96e3fcc6f3c04d9080e35f7d6ba0f6c9"></a><!-- doxytag: member="Tes::IO::PacketBuffer::ValidHeader" ref="a96e3fcc6f3c04d9080e35f7d6ba0f6c9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tes::IO::PacketBuffer::ValidHeader<code> [get, set]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is the header valid? </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>PacketBuffer.cs</li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>Tes</b>      </li>
      <li class="navelem"><a class="el" href="namespaceTes_1_1IO.html">IO</a>      </li>
      <li class="navelem"><a class="el" href="classTes_1_1IO_1_1PacketBuffer.html">PacketBuffer</a>      </li>
      <li class="footer">Generated by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Events</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
