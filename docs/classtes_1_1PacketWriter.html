<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>3es: tes::PacketWriter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">3es
   &#160;<span id="projectnumber">0.7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classtes_1_1PacketWriter.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classtes_1_1PacketWriter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tes::PacketWriter Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A utility class for writing payload data to a <code><a class="el" href="structtes_1_1PacketHeader.html" title="The header for an incoming 3ES data packet. ">PacketHeader</a></code>.  
 <a href="classtes_1_1PacketWriter.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="3espacketwriter_8h_source.html">3espacketwriter.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tes::PacketWriter:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classtes_1_1PacketWriter.png" usemap="#tes::PacketWriter_map" alt=""/>
  <map id="tes::PacketWriter_map" name="tes::PacketWriter_map">
<area href="classtes_1_1PacketStream.html" alt="tes::PacketStream&lt; PacketHeader &gt;" shape="rect" coords="0,0,215,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab18b3d8f42edba797b17b50f3577a791"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#ab18b3d8f42edba797b17b50f3577a791">PacketWriter</a> (<a class="el" href="structtes_1_1PacketHeader.html">PacketHeader</a> &amp;packet, uint16_t <a class="el" href="classtes_1_1PacketWriter.html#a7644efc5ae740087a5a784c19e6e9fc3">maxPayloadSize</a>, uint16_t <a class="el" href="classtes_1_1PacketStream.html#a8f93e2dcbc34db04d02691fc191507a9">routingId</a>=0, uint16_t <a class="el" href="classtes_1_1PacketStream.html#a2ccd85aa75fcc2d8a456b517cf5e79d7">messageId</a>=0)</td></tr>
<tr class="memdesc:ab18b3d8f42edba797b17b50f3577a791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="classtes_1_1PacketWriter.html" title="A utility class for writing payload data to a PacketHeader. ">PacketWriter</a></code> to write to the given <code>packet</code>.  <a href="#ab18b3d8f42edba797b17b50f3577a791">More...</a><br /></td></tr>
<tr class="separator:ab18b3d8f42edba797b17b50f3577a791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a4645e149622aef5cd9e6eaafb9e48"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#af2a4645e149622aef5cd9e6eaafb9e48">PacketWriter</a> (uint8_t *buffer, uint16_t bufferSize, uint16_t <a class="el" href="classtes_1_1PacketStream.html#a8f93e2dcbc34db04d02691fc191507a9">routingId</a>=0, uint16_t <a class="el" href="classtes_1_1PacketStream.html#a2ccd85aa75fcc2d8a456b517cf5e79d7">messageId</a>=0)</td></tr>
<tr class="memdesc:af2a4645e149622aef5cd9e6eaafb9e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="classtes_1_1PacketWriter.html" title="A utility class for writing payload data to a PacketHeader. ">PacketWriter</a></code> to write to the given byte buffer.  <a href="#af2a4645e149622aef5cd9e6eaafb9e48">More...</a><br /></td></tr>
<tr class="separator:af2a4645e149622aef5cd9e6eaafb9e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871feef1eded8c54f334ede292da1729"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#a871feef1eded8c54f334ede292da1729">PacketWriter</a> (const <a class="el" href="classtes_1_1PacketWriter.html">PacketWriter</a> &amp;other)</td></tr>
<tr class="memdesc:a871feef1eded8c54f334ede292da1729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a871feef1eded8c54f334ede292da1729">More...</a><br /></td></tr>
<tr class="separator:a871feef1eded8c54f334ede292da1729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610b3612c1d888e2ef344bf71b7d9b3f"><td class="memItemLeft" align="right" valign="top"><a id="a610b3612c1d888e2ef344bf71b7d9b3f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#a610b3612c1d888e2ef344bf71b7d9b3f">~PacketWriter</a> ()</td></tr>
<tr class="memdesc:a610b3612c1d888e2ef344bf71b7d9b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor, ensuring the CRC is calculated. <br /></td></tr>
<tr class="separator:a610b3612c1d888e2ef344bf71b7d9b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9205cb7bb4d151d238304f6b0bc006"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtes_1_1PacketWriter.html">PacketWriter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#a3d9205cb7bb4d151d238304f6b0bc006">operator=</a> (const <a class="el" href="classtes_1_1PacketWriter.html">PacketWriter</a> &amp;other)</td></tr>
<tr class="memdesc:a3d9205cb7bb4d151d238304f6b0bc006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a3d9205cb7bb4d151d238304f6b0bc006">More...</a><br /></td></tr>
<tr class="separator:a3d9205cb7bb4d151d238304f6b0bc006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2403fbd4f2ef4853bfa9083f31b3386c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#a2403fbd4f2ef4853bfa9083f31b3386c">reset</a> (uint16_t <a class="el" href="classtes_1_1PacketStream.html#a8f93e2dcbc34db04d02691fc191507a9">routingId</a>, uint16_t <a class="el" href="classtes_1_1PacketStream.html#a2ccd85aa75fcc2d8a456b517cf5e79d7">messageId</a>)</td></tr>
<tr class="memdesc:a2403fbd4f2ef4853bfa9083f31b3386c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the packet, clearing out all variable data including the payload, crc and routing id.  <a href="#a2403fbd4f2ef4853bfa9083f31b3386c">More...</a><br /></td></tr>
<tr class="separator:a2403fbd4f2ef4853bfa9083f31b3386c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacf09dcab7be257dc2059148c2cdb99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#adacf09dcab7be257dc2059148c2cdb99">reset</a> ()</td></tr>
<tr class="separator:adacf09dcab7be257dc2059148c2cdb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf08e95affecbbdeb20d3894aadfa032"><td class="memItemLeft" align="right" valign="top"><a id="acf08e95affecbbdeb20d3894aadfa032"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setRoutingId</b> (uint16_t <a class="el" href="classtes_1_1PacketStream.html#a8f93e2dcbc34db04d02691fc191507a9">routingId</a>)</td></tr>
<tr class="separator:acf08e95affecbbdeb20d3894aadfa032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24880539cdc128cb155e191231ab40fc"><td class="memItemLeft" align="right" valign="top"><a id="a24880539cdc128cb155e191231ab40fc"></a>
<a class="el" href="structtes_1_1PacketHeader.html">PacketHeader</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>packet</b> () const</td></tr>
<tr class="separator:a24880539cdc128cb155e191231ab40fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ec01f2f0924a439b681d85813a5ba7"><td class="memItemLeft" align="right" valign="top"><a id="a91ec01f2f0924a439b681d85813a5ba7"></a>
const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> () const</td></tr>
<tr class="separator:a91ec01f2f0924a439b681d85813a5ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7c84e4dc16b44ac38f5df36b19e3c5"><td class="memItemLeft" align="right" valign="top"><a id="aff7c84e4dc16b44ac38f5df36b19e3c5"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>payload</b> ()</td></tr>
<tr class="separator:aff7c84e4dc16b44ac38f5df36b19e3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79174d99e9466f4817ebf44199683039"><td class="memItemLeft" align="right" valign="top"><a id="a79174d99e9466f4817ebf44199683039"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>invalidateCrc</b> ()</td></tr>
<tr class="separator:a79174d99e9466f4817ebf44199683039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b2fc6a76e321de5e78a83a09d33b4e"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#a48b2fc6a76e321de5e78a83a09d33b4e">bytesRemaining</a> () const</td></tr>
<tr class="memdesc:a48b2fc6a76e321de5e78a83a09d33b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes remaining available in the payload.  <a href="#a48b2fc6a76e321de5e78a83a09d33b4e">More...</a><br /></td></tr>
<tr class="separator:a48b2fc6a76e321de5e78a83a09d33b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7644efc5ae740087a5a784c19e6e9fc3"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#a7644efc5ae740087a5a784c19e6e9fc3">maxPayloadSize</a> () const</td></tr>
<tr class="memdesc:a7644efc5ae740087a5a784c19e6e9fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the payload buffer.  <a href="#a7644efc5ae740087a5a784c19e6e9fc3">More...</a><br /></td></tr>
<tr class="separator:a7644efc5ae740087a5a784c19e6e9fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cfacf0917a1392780302d5e3a1d4ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#af1cfacf0917a1392780302d5e3a1d4ca">finalise</a> ()</td></tr>
<tr class="memdesc:af1cfacf0917a1392780302d5e3a1d4ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalises the packet for sending, calculating the CRC.  <a href="#af1cfacf0917a1392780302d5e3a1d4ca">More...</a><br /></td></tr>
<tr class="separator:af1cfacf0917a1392780302d5e3a1d4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b60dfd5fa3e1925f34db7d3573a866"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtes_1_1PacketStream.html#a86786079cd197b03966585a7cc0c9ffe">CrcType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#ab1b60dfd5fa3e1925f34db7d3573a866">calculateCrc</a> ()</td></tr>
<tr class="memdesc:ab1b60dfd5fa3e1925f34db7d3573a866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the CRC and writes it to the <code><a class="el" href="structtes_1_1PacketHeader.html" title="The header for an incoming 3ES data packet. ">PacketHeader</a></code> crc member.  <a href="#ab1b60dfd5fa3e1925f34db7d3573a866">More...</a><br /></td></tr>
<tr class="separator:ab1b60dfd5fa3e1925f34db7d3573a866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d88d43b9acc2bc84022bdbea155f1e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#a67d88d43b9acc2bc84022bdbea155f1e">writeElement</a> (const uint8_t *bytes, size_t elementSize)</td></tr>
<tr class="memdesc:a67d88d43b9acc2bc84022bdbea155f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a single data element from the current position.  <a href="#a67d88d43b9acc2bc84022bdbea155f1e">More...</a><br /></td></tr>
<tr class="separator:a67d88d43b9acc2bc84022bdbea155f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f56e63c059deec646d0e2ea2977bf1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#ac1f56e63c059deec646d0e2ea2977bf1">writeArray</a> (const uint8_t *bytes, size_t elementSize, size_t elementCount)</td></tr>
<tr class="memdesc:ac1f56e63c059deec646d0e2ea2977bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an array of data items from the current position.  <a href="#ac1f56e63c059deec646d0e2ea2977bf1">More...</a><br /></td></tr>
<tr class="separator:ac1f56e63c059deec646d0e2ea2977bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd9861810d73255c301e02181fcda0c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#a4cd9861810d73255c301e02181fcda0c">writeRaw</a> (const uint8_t *bytes, size_t byteCount)</td></tr>
<tr class="memdesc:a4cd9861810d73255c301e02181fcda0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes raw bytes from the packet at the current position up to <code>byteCount</code>.  <a href="#a4cd9861810d73255c301e02181fcda0c">More...</a><br /></td></tr>
<tr class="separator:a4cd9861810d73255c301e02181fcda0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fd2765dfdd18c3e2e182a8c35cbcc6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a93fd2765dfdd18c3e2e182a8c35cbcc6"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#a93fd2765dfdd18c3e2e182a8c35cbcc6">writeElement</a> (const T &amp;element)</td></tr>
<tr class="memdesc:a93fd2765dfdd18c3e2e182a8c35cbcc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a single data item from the packet.  <a href="#a93fd2765dfdd18c3e2e182a8c35cbcc6">More...</a><br /></td></tr>
<tr class="separator:a93fd2765dfdd18c3e2e182a8c35cbcc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57de3167048820582e9046e786f260d1"><td class="memTemplParams" colspan="2"><a id="a57de3167048820582e9046e786f260d1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a57de3167048820582e9046e786f260d1"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>writeArray</b> (const T *elements, size_t elementCount)</td></tr>
<tr class="separator:a57de3167048820582e9046e786f260d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4337471ec1b6d5906023df7499c1eb"><td class="memTemplParams" colspan="2"><a id="adf4337471ec1b6d5906023df7499c1eb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adf4337471ec1b6d5906023df7499c1eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtes_1_1PacketWriter.html">PacketWriter</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (T &amp;val)</td></tr>
<tr class="separator:adf4337471ec1b6d5906023df7499c1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classtes_1_1PacketStream"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classtes_1_1PacketStream')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classtes_1_1PacketStream.html">tes::PacketStream&lt; PacketHeader &gt;</a></td></tr>
<tr class="memitem:ac69b9e5865748bfaa322e1c0e1555191 inherit pub_methods_classtes_1_1PacketStream"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketStream.html#ac69b9e5865748bfaa322e1c0e1555191">PacketStream</a> (<a class="el" href="structtes_1_1PacketHeader.html">PacketHeader</a> &amp;<a class="el" href="classtes_1_1PacketStream.html#a6488d308a01f57f0368a5d3ca3f14762">packet</a>)</td></tr>
<tr class="memdesc:ac69b9e5865748bfaa322e1c0e1555191 inherit pub_methods_classtes_1_1PacketStream"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a stream to read from beginning at <code>packet</code>.  <a href="classtes_1_1PacketStream.html#ac69b9e5865748bfaa322e1c0e1555191">More...</a><br /></td></tr>
<tr class="separator:ac69b9e5865748bfaa322e1c0e1555191 inherit pub_methods_classtes_1_1PacketStream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af613d0c2b8e4bab8ad29b16a66feec4f inherit pub_methods_classtes_1_1PacketStream"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketStream.html#af613d0c2b8e4bab8ad29b16a66feec4f">marker</a> () const</td></tr>
<tr class="memdesc:af613d0c2b8e4bab8ad29b16a66feec4f inherit pub_methods_classtes_1_1PacketStream"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the marker bytes in local endian.  <a href="classtes_1_1PacketStream.html#af613d0c2b8e4bab8ad29b16a66feec4f">More...</a><br /></td></tr>
<tr class="separator:af613d0c2b8e4bab8ad29b16a66feec4f inherit pub_methods_classtes_1_1PacketStream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996f7eb7b5f6f9edc8f49c7a8fdff68b inherit pub_methods_classtes_1_1PacketStream"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketStream.html#a996f7eb7b5f6f9edc8f49c7a8fdff68b">versionMajor</a> () const</td></tr>
<tr class="memdesc:a996f7eb7b5f6f9edc8f49c7a8fdff68b inherit pub_methods_classtes_1_1PacketStream"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the major version bytes in local endian.  <a href="classtes_1_1PacketStream.html#a996f7eb7b5f6f9edc8f49c7a8fdff68b">More...</a><br /></td></tr>
<tr class="separator:a996f7eb7b5f6f9edc8f49c7a8fdff68b inherit pub_methods_classtes_1_1PacketStream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d05343f606c1fa246f729ed5ecd131e inherit pub_methods_classtes_1_1PacketStream"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketStream.html#a5d05343f606c1fa246f729ed5ecd131e">versionMinor</a> () const</td></tr>
<tr class="memdesc:a5d05343f606c1fa246f729ed5ecd131e inherit pub_methods_classtes_1_1PacketStream"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the minor version bytes in local endian.  <a href="classtes_1_1PacketStream.html#a5d05343f606c1fa246f729ed5ecd131e">More...</a><br /></td></tr>
<tr class="separator:a5d05343f606c1fa246f729ed5ecd131e inherit pub_methods_classtes_1_1PacketStream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5734b6d8ba615b5784b0c8ebc9057a29 inherit pub_methods_classtes_1_1PacketStream"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketStream.html#a5734b6d8ba615b5784b0c8ebc9057a29">payloadSize</a> () const</td></tr>
<tr class="memdesc:a5734b6d8ba615b5784b0c8ebc9057a29 inherit pub_methods_classtes_1_1PacketStream"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the payload size bytes in local endian.  <a href="classtes_1_1PacketStream.html#a5734b6d8ba615b5784b0c8ebc9057a29">More...</a><br /></td></tr>
<tr class="separator:a5734b6d8ba615b5784b0c8ebc9057a29 inherit pub_methods_classtes_1_1PacketStream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a17f9efd4b798ddd9f607b37d51cba inherit pub_methods_classtes_1_1PacketStream"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketStream.html#a11a17f9efd4b798ddd9f607b37d51cba">packetSize</a> () const</td></tr>
<tr class="memdesc:a11a17f9efd4b798ddd9f607b37d51cba inherit pub_methods_classtes_1_1PacketStream"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the packet plus payload, giving the full data packet size including the CRC.  <a href="classtes_1_1PacketStream.html#a11a17f9efd4b798ddd9f607b37d51cba">More...</a><br /></td></tr>
<tr class="separator:a11a17f9efd4b798ddd9f607b37d51cba inherit pub_methods_classtes_1_1PacketStream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f93e2dcbc34db04d02691fc191507a9 inherit pub_methods_classtes_1_1PacketStream"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketStream.html#a8f93e2dcbc34db04d02691fc191507a9">routingId</a> () const</td></tr>
<tr class="memdesc:a8f93e2dcbc34db04d02691fc191507a9 inherit pub_methods_classtes_1_1PacketStream"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the routing ID bytes in local endian.  <a href="classtes_1_1PacketStream.html#a8f93e2dcbc34db04d02691fc191507a9">More...</a><br /></td></tr>
<tr class="separator:a8f93e2dcbc34db04d02691fc191507a9 inherit pub_methods_classtes_1_1PacketStream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccd85aa75fcc2d8a456b517cf5e79d7 inherit pub_methods_classtes_1_1PacketStream"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketStream.html#a2ccd85aa75fcc2d8a456b517cf5e79d7">messageId</a> () const</td></tr>
<tr class="memdesc:a2ccd85aa75fcc2d8a456b517cf5e79d7 inherit pub_methods_classtes_1_1PacketStream"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the message ID bytes in local endian.  <a href="classtes_1_1PacketStream.html#a2ccd85aa75fcc2d8a456b517cf5e79d7">More...</a><br /></td></tr>
<tr class="separator:a2ccd85aa75fcc2d8a456b517cf5e79d7 inherit pub_methods_classtes_1_1PacketStream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c7d3a13ecdeaa3d651b18839caa5f5 inherit pub_methods_classtes_1_1PacketStream"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtes_1_1PacketStream.html#a86786079cd197b03966585a7cc0c9ffe">CrcType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketStream.html#a68c7d3a13ecdeaa3d651b18839caa5f5">crc</a> () const</td></tr>
<tr class="memdesc:a68c7d3a13ecdeaa3d651b18839caa5f5 inherit pub_methods_classtes_1_1PacketStream"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the CRC bytes in local endian.  <a href="classtes_1_1PacketStream.html#a68c7d3a13ecdeaa3d651b18839caa5f5">More...</a><br /></td></tr>
<tr class="separator:a68c7d3a13ecdeaa3d651b18839caa5f5 inherit pub_methods_classtes_1_1PacketStream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84b049afcca7c22ef179fbd093c2ab8 inherit pub_methods_classtes_1_1PacketStream"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtes_1_1PacketStream.html#a86786079cd197b03966585a7cc0c9ffe">CrcType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketStream.html#ab84b049afcca7c22ef179fbd093c2ab8">crcPtr</a> ()</td></tr>
<tr class="memdesc:ab84b049afcca7c22ef179fbd093c2ab8 inherit pub_methods_classtes_1_1PacketStream"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a pointer to the CRC bytes.  <a href="classtes_1_1PacketStream.html#ab84b049afcca7c22ef179fbd093c2ab8">More...</a><br /></td></tr>
<tr class="separator:ab84b049afcca7c22ef179fbd093c2ab8 inherit pub_methods_classtes_1_1PacketStream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2695dfa90f64fa675ebe5b6d4d01fbac inherit pub_methods_classtes_1_1PacketStream"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtes_1_1PacketStream.html#a86786079cd197b03966585a7cc0c9ffe">CrcType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketStream.html#a2695dfa90f64fa675ebe5b6d4d01fbac">crcPtr</a> () const</td></tr>
<tr class="separator:a2695dfa90f64fa675ebe5b6d4d01fbac inherit pub_methods_classtes_1_1PacketStream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb46926eadc691d064139f5236af3cd inherit pub_methods_classtes_1_1PacketStream"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketStream.html#a4cb46926eadc691d064139f5236af3cd">status</a> () const</td></tr>
<tr class="memdesc:a4cb46926eadc691d064139f5236af3cd inherit pub_methods_classtes_1_1PacketStream"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the <code>Status</code> bits.  <a href="classtes_1_1PacketStream.html#a4cb46926eadc691d064139f5236af3cd">More...</a><br /></td></tr>
<tr class="separator:a4cb46926eadc691d064139f5236af3cd inherit pub_methods_classtes_1_1PacketStream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8607c63d25f27599ec9898d27318a5b inherit pub_methods_classtes_1_1PacketStream"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketStream.html#aa8607c63d25f27599ec9898d27318a5b">isEop</a> () const</td></tr>
<tr class="memdesc:aa8607c63d25f27599ec9898d27318a5b inherit pub_methods_classtes_1_1PacketStream"><td class="mdescLeft">&#160;</td><td class="mdescRight">At end of packet/stream?  <a href="classtes_1_1PacketStream.html#aa8607c63d25f27599ec9898d27318a5b">More...</a><br /></td></tr>
<tr class="separator:aa8607c63d25f27599ec9898d27318a5b inherit pub_methods_classtes_1_1PacketStream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabb07232ec04ef63b55a53cba84eab7 inherit pub_methods_classtes_1_1PacketStream"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketStream.html#aaabb07232ec04ef63b55a53cba84eab7">isOk</a> () const</td></tr>
<tr class="memdesc:aaabb07232ec04ef63b55a53cba84eab7 inherit pub_methods_classtes_1_1PacketStream"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status OK?  <a href="classtes_1_1PacketStream.html#aaabb07232ec04ef63b55a53cba84eab7">More...</a><br /></td></tr>
<tr class="separator:aaabb07232ec04ef63b55a53cba84eab7 inherit pub_methods_classtes_1_1PacketStream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af193aa07f9f7a85063f9040d1d84ea57 inherit pub_methods_classtes_1_1PacketStream"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketStream.html#af193aa07f9f7a85063f9040d1d84ea57">isFail</a> () const</td></tr>
<tr class="memdesc:af193aa07f9f7a85063f9040d1d84ea57 inherit pub_methods_classtes_1_1PacketStream"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fail bit set?  <a href="classtes_1_1PacketStream.html#af193aa07f9f7a85063f9040d1d84ea57">More...</a><br /></td></tr>
<tr class="separator:af193aa07f9f7a85063f9040d1d84ea57 inherit pub_methods_classtes_1_1PacketStream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b44f57d0b1d9738c2d11ebf4a3130a inherit pub_methods_classtes_1_1PacketStream"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketStream.html#a45b44f57d0b1d9738c2d11ebf4a3130a">isReadOnly</a> () const</td></tr>
<tr class="memdesc:a45b44f57d0b1d9738c2d11ebf4a3130a inherit pub_methods_classtes_1_1PacketStream"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read only stream?  <a href="classtes_1_1PacketStream.html#a45b44f57d0b1d9738c2d11ebf4a3130a">More...</a><br /></td></tr>
<tr class="separator:a45b44f57d0b1d9738c2d11ebf4a3130a inherit pub_methods_classtes_1_1PacketStream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde01d082152a4668aaee440efad4ea9 inherit pub_methods_classtes_1_1PacketStream"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketStream.html#acde01d082152a4668aaee440efad4ea9">isCrcValid</a> () const</td></tr>
<tr class="memdesc:acde01d082152a4668aaee440efad4ea9 inherit pub_methods_classtes_1_1PacketStream"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRC validated?  <a href="classtes_1_1PacketStream.html#acde01d082152a4668aaee440efad4ea9">More...</a><br /></td></tr>
<tr class="separator:acde01d082152a4668aaee440efad4ea9 inherit pub_methods_classtes_1_1PacketStream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6488d308a01f57f0368a5d3ca3f14762 inherit pub_methods_classtes_1_1PacketStream"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtes_1_1PacketHeader.html">PacketHeader</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketStream.html#a6488d308a01f57f0368a5d3ca3f14762">packet</a> () const</td></tr>
<tr class="memdesc:a6488d308a01f57f0368a5d3ca3f14762 inherit pub_methods_classtes_1_1PacketStream"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the head of the packet buffer, for direct <code>PacketHeader</code> access.  <a href="classtes_1_1PacketStream.html#a6488d308a01f57f0368a5d3ca3f14762">More...</a><br /></td></tr>
<tr class="separator:a6488d308a01f57f0368a5d3ca3f14762 inherit pub_methods_classtes_1_1PacketStream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e388b46d418ba431d07a6899a133fd inherit pub_methods_classtes_1_1PacketStream"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketStream.html#a19e388b46d418ba431d07a6899a133fd">tell</a> () const</td></tr>
<tr class="memdesc:a19e388b46d418ba431d07a6899a133fd inherit pub_methods_classtes_1_1PacketStream"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the current stream position.  <a href="classtes_1_1PacketStream.html#a19e388b46d418ba431d07a6899a133fd">More...</a><br /></td></tr>
<tr class="separator:a19e388b46d418ba431d07a6899a133fd inherit pub_methods_classtes_1_1PacketStream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932c36320dec523bdf8617df293da732 inherit pub_methods_classtes_1_1PacketStream"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketStream.html#a932c36320dec523bdf8617df293da732">seek</a> (int offset, <a class="el" href="classtes_1_1PacketStream.html#a1a1503c7c30c706fd02b3d8dedbb1772">SeekPos</a> pos=<a class="el" href="classtes_1_1PacketStream.html#a1a1503c7c30c706fd02b3d8dedbb1772ac7ce42acc4eb14db94169478b9ad8c9d">Begin</a>)</td></tr>
<tr class="memdesc:a932c36320dec523bdf8617df293da732 inherit pub_methods_classtes_1_1PacketStream"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek to the indicated position.  <a href="classtes_1_1PacketStream.html#a932c36320dec523bdf8617df293da732">More...</a><br /></td></tr>
<tr class="separator:a932c36320dec523bdf8617df293da732 inherit pub_methods_classtes_1_1PacketStream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971cc591322fbb320f4f9e1ff2e0743f inherit pub_methods_classtes_1_1PacketStream"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketStream.html#a971cc591322fbb320f4f9e1ff2e0743f">payload</a> () const</td></tr>
<tr class="memdesc:a971cc591322fbb320f4f9e1ff2e0743f inherit pub_methods_classtes_1_1PacketStream"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct payload pointer access.  <a href="classtes_1_1PacketStream.html#a971cc591322fbb320f4f9e1ff2e0743f">More...</a><br /></td></tr>
<tr class="separator:a971cc591322fbb320f4f9e1ff2e0743f inherit pub_methods_classtes_1_1PacketStream"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1dfd6daf615a5f1e0f17d3cc933835d3"><td class="memItemLeft" align="right" valign="top"><a id="a1dfd6daf615a5f1e0f17d3cc933835d3"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>payloadWritePtr</b> ()</td></tr>
<tr class="separator:a1dfd6daf615a5f1e0f17d3cc933835d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b30a0f5deb198e846725c70f98c512"><td class="memItemLeft" align="right" valign="top"><a id="ae7b30a0f5deb198e846725c70f98c512"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>incrementPayloadSize</b> (size_t inc)</td></tr>
<tr class="separator:ae7b30a0f5deb198e846725c70f98c512"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a20ab3d567265f1d424df3b92c9208794"><td class="memItemLeft" align="right" valign="top"><a id="a20ab3d567265f1d424df3b92c9208794"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>_bufferSize</b></td></tr>
<tr class="separator:a20ab3d567265f1d424df3b92c9208794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classtes_1_1PacketStream"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classtes_1_1PacketStream')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classtes_1_1PacketStream.html">tes::PacketStream&lt; PacketHeader &gt;</a></td></tr>
<tr class="memitem:ab0d510c8c1c97ce4820087ef163dbe67 inherit pro_attribs_classtes_1_1PacketStream"><td class="memItemLeft" align="right" valign="top"><a id="ab0d510c8c1c97ce4820087ef163dbe67"></a>
<a class="el" href="structtes_1_1PacketHeader.html">PacketHeader</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketStream.html#ab0d510c8c1c97ce4820087ef163dbe67">_packet</a></td></tr>
<tr class="memdesc:ab0d510c8c1c97ce4820087ef163dbe67 inherit pro_attribs_classtes_1_1PacketStream"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packet header and buffer start address. <br /></td></tr>
<tr class="separator:ab0d510c8c1c97ce4820087ef163dbe67 inherit pro_attribs_classtes_1_1PacketStream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959280fbfcbfb251aef216bf9b044788 inherit pro_attribs_classtes_1_1PacketStream"><td class="memItemLeft" align="right" valign="top"><a id="a959280fbfcbfb251aef216bf9b044788"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketStream.html#a959280fbfcbfb251aef216bf9b044788">_status</a></td></tr>
<tr class="memdesc:a959280fbfcbfb251aef216bf9b044788 inherit pro_attribs_classtes_1_1PacketStream"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>Status</code> bits. <br /></td></tr>
<tr class="separator:a959280fbfcbfb251aef216bf9b044788 inherit pro_attribs_classtes_1_1PacketStream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388a12cc1b2d3a4ff3fe566bcfdccea0 inherit pro_attribs_classtes_1_1PacketStream"><td class="memItemLeft" align="right" valign="top"><a id="a388a12cc1b2d3a4ff3fe566bcfdccea0"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketStream.html#a388a12cc1b2d3a4ff3fe566bcfdccea0">_payloadPosition</a></td></tr>
<tr class="memdesc:a388a12cc1b2d3a4ff3fe566bcfdccea0 inherit pro_attribs_classtes_1_1PacketStream"><td class="mdescLeft">&#160;</td><td class="mdescRight">Payload cursor. <br /></td></tr>
<tr class="separator:a388a12cc1b2d3a4ff3fe566bcfdccea0 inherit pro_attribs_classtes_1_1PacketStream"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classtes_1_1PacketStream"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classtes_1_1PacketStream')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classtes_1_1PacketStream.html">tes::PacketStream&lt; PacketHeader &gt;</a></td></tr>
<tr class="memitem:a1a1503c7c30c706fd02b3d8dedbb1772 inherit pub_types_classtes_1_1PacketStream"><td class="memItemLeft" align="right" valign="top"><a id="a1a1503c7c30c706fd02b3d8dedbb1772"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketStream.html#a1a1503c7c30c706fd02b3d8dedbb1772">SeekPos</a> <tr class="memdesc:a1a1503c7c30c706fd02b3d8dedbb1772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control values for seeking. <br /></td></tr>
</td></tr>
<tr class="separator:a1a1503c7c30c706fd02b3d8dedbb1772 inherit pub_types_classtes_1_1PacketStream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4424076bb90e3f85a0d91ab5d3f2ce67 inherit pub_types_classtes_1_1PacketStream"><td class="memItemLeft" align="right" valign="top"><a id="a4424076bb90e3f85a0d91ab5d3f2ce67"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketStream.html#a4424076bb90e3f85a0d91ab5d3f2ce67">Status</a> <tr class="memdesc:a4424076bb90e3f85a0d91ab5d3f2ce67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status bits. <br /></td></tr>
</td></tr>
<tr class="separator:a4424076bb90e3f85a0d91ab5d3f2ce67 inherit pub_types_classtes_1_1PacketStream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86786079cd197b03966585a7cc0c9ffe inherit pub_types_classtes_1_1PacketStream"><td class="memItemLeft" align="right" valign="top"><a id="a86786079cd197b03966585a7cc0c9ffe"></a>
typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketStream.html#a86786079cd197b03966585a7cc0c9ffe">CrcType</a></td></tr>
<tr class="memdesc:a86786079cd197b03966585a7cc0c9ffe inherit pub_types_classtes_1_1PacketStream"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defies the packet CRC type. <br /></td></tr>
<tr class="separator:a86786079cd197b03966585a7cc0c9ffe inherit pub_types_classtes_1_1PacketStream"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A utility class for writing payload data to a <code><a class="el" href="structtes_1_1PacketHeader.html" title="The header for an incoming 3ES data packet. ">PacketHeader</a></code>. </p>
<p>This keeps the <code><a class="el" href="structtes_1_1PacketHeader.html" title="The header for an incoming 3ES data packet. ">PacketHeader</a></code> <code>payloadSize</code> member up to date and ensures the CRC is calculated, either via <code><a class="el" href="classtes_1_1PacketWriter.html#ab1b60dfd5fa3e1925f34db7d3573a866" title="Calculates the CRC and writes it to the PacketHeader crc member. ">calculateCrc()</a></code> explicitly on on destruction.</p>
<p>The payload buffer size must be specified in the constructor, and data writes are limited by this value. The packet is assumed to be structured such that the packet header is located at the start of the buffer, followed immediately by space for the payload.</p>
<p>Two construction options are available, one where the <code><a class="el" href="structtes_1_1PacketHeader.html" title="The header for an incoming 3ES data packet. ">PacketHeader</a></code> details are already initialised, except for the <code>payloadSize</code> and <code>crc</code>. The given packet is assumed to be the start of the data buffer. The second constructor accepts a raw byte pointer, which marks the start of the buffer, and the size of the buffer. The buffer size must be large enough for the @ <a class="el" href="structtes_1_1PacketHeader.html" title="The header for an incoming 3ES data packet. ">PacketHeader</a>. Remaining space is available for the payload.</p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000003">Bug:</a></b></dt><dd>Use the payloadOffset in various calculations herein. It was added after this class was written, but is currently only supported as being zero, so it's not an issue yet. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab18b3d8f42edba797b17b50f3577a791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18b3d8f42edba797b17b50f3577a791">&#9670;&nbsp;</a></span>PacketWriter() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tes::PacketWriter::PacketWriter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtes_1_1PacketHeader.html">PacketHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>maxPayloadSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>routingId</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>messageId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <code><a class="el" href="classtes_1_1PacketWriter.html" title="A utility class for writing payload data to a PacketHeader. ">PacketWriter</a></code> to write to the given <code>packet</code>. </p>
<p>This marks the start of the packet buffer.</p>
<p>The packet members are initialised, but <code>payloadSize</code> and <code>crc</code> are left at zero to be calculated later. The <code>routingId</code> maybe given now or set with <code>setRoutingId()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>The packet to write to. </td></tr>
    <tr><td class="paramname">maxPayloadSize</td><td>Specifies the space available for the payload (bytes). This is in excess of the packet size, not the total buffer size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2a4645e149622aef5cd9e6eaafb9e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a4645e149622aef5cd9e6eaafb9e48">&#9670;&nbsp;</a></span>PacketWriter() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tes::PacketWriter::PacketWriter </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>routingId</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>messageId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <code><a class="el" href="classtes_1_1PacketWriter.html" title="A utility class for writing payload data to a PacketHeader. ">PacketWriter</a></code> to write to the given byte buffer. </p>
<p>The buffer size must be at least <code>sizeof(PacketHeader)</code>, larger if any payload is required. If not, then the <code><a class="el" href="classtes_1_1PacketStream.html#af193aa07f9f7a85063f9040d1d84ea57" title="Fail bit set? ">isFail()</a></code> will be true and all write operations will fail.</p>
<p>The <code>routingId</code> maybe given now or set with <code>setRoutingId()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The packet data buffer. </td></tr>
    <tr><td class="paramname">bufferSize</td><td>The total number of bytes available for the <code><a class="el" href="structtes_1_1PacketHeader.html" title="The header for an incoming 3ES data packet. ">PacketHeader</a></code> and its paylaod. Must be at least <code>sizeof(PacketHeader)</code>, or all writing will fail. </td></tr>
    <tr><td class="paramname">routingId</td><td>Optionlly sets the <code>routingId</code> member of the packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a871feef1eded8c54f334ede292da1729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871feef1eded8c54f334ede292da1729">&#9670;&nbsp;</a></span>PacketWriter() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tes::PacketWriter::PacketWriter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtes_1_1PacketWriter.html">PacketWriter</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Simple as neither writer owns the underlying memory. Both point to the same underlying memory, but only one should be used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The packet to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a48b2fc6a76e321de5e78a83a09d33b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b2fc6a76e321de5e78a83a09d33b4e">&#9670;&nbsp;</a></span>bytesRemaining()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t tes::PacketWriter::bytesRemaining </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of bytes remaining available in the payload. </p>
<p>This is calculated as the <code><a class="el" href="classtes_1_1PacketWriter.html#a7644efc5ae740087a5a784c19e6e9fc3" title="Returns the size of the payload buffer. ">maxPayloadSize()</a></code> - <code><a class="el" href="classtes_1_1PacketStream.html#a5734b6d8ba615b5784b0c8ebc9057a29" title="Fetch the payload size bytes in local endian. ">payloadSize()</a></code>. </p><dl class="section return"><dt>Returns</dt><dd>Number of bytes remaining available for write. </dd></dl>

</div>
</div>
<a id="ab1b60dfd5fa3e1925f34db7d3573a866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b60dfd5fa3e1925f34db7d3573a866">&#9670;&nbsp;</a></span>calculateCrc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtes_1_1PacketStream.html#a86786079cd197b03966585a7cc0c9ffe">CrcType</a> tes::PacketWriter::calculateCrc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the CRC and writes it to the <code><a class="el" href="structtes_1_1PacketHeader.html" title="The header for an incoming 3ES data packet. ">PacketHeader</a></code> crc member. </p>
<p>The current CRC value is returned when <code><a class="el" href="classtes_1_1PacketStream.html#acde01d082152a4668aaee440efad4ea9" title="CRC validated? ">isCrcValid()</a></code> is true. The CRC will not be calculate when <code><a class="el" href="classtes_1_1PacketStream.html#af193aa07f9f7a85063f9040d1d84ea57" title="Fail bit set? ">isFail()</a></code> is true and the result is undefined. </p><dl class="section return"><dt>Returns</dt><dd>The Calculated CRC, or undifined when <code><a class="el" href="classtes_1_1PacketStream.html#af193aa07f9f7a85063f9040d1d84ea57" title="Fail bit set? ">isFail()</a></code>. </dd></dl>

</div>
</div>
<a id="af1cfacf0917a1392780302d5e3a1d4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1cfacf0917a1392780302d5e3a1d4ca">&#9670;&nbsp;</a></span>finalise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tes::PacketWriter::finalise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalises the packet for sending, calculating the CRC. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the packet is valid and ready for sending. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespacetes.html#a53f78d5d7f91d0889ffd201fd1f37098">tes::sendMessage()</a>.</p>

</div>
</div>
<a id="a7644efc5ae740087a5a784c19e6e9fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7644efc5ae740087a5a784c19e6e9fc3">&#9670;&nbsp;</a></span>maxPayloadSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t tes::PacketWriter::maxPayloadSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the payload buffer. </p>
<p>This is the maximum number of bytes which can be written to the payload. </p><dl class="section return"><dt>Returns</dt><dd>The payload buffer size (bytes). </dd></dl>

</div>
</div>
<a id="a3d9205cb7bb4d151d238304f6b0bc006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9205cb7bb4d151d238304f6b0bc006">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtes_1_1PacketWriter.html">PacketWriter</a>&amp; tes::PacketWriter::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtes_1_1PacketWriter.html">PacketWriter</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>Simple as neither writer owns the underlying memory. Both point to the same underlying memory, but only one should be used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The packet to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2403fbd4f2ef4853bfa9083f31b3386c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2403fbd4f2ef4853bfa9083f31b3386c">&#9670;&nbsp;</a></span>reset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tes::PacketWriter::reset </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>routingId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>messageId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the packet, clearing out all variable data including the payload, crc and routing id. </p>
<p>Allows preparation for writing new data to the same payload buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">routingId</td><td>Optional specification for the <code>routingId</code> after reset. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="namespacetes.html#a53f78d5d7f91d0889ffd201fd1f37098">tes::sendMessage()</a>.</p>

</div>
</div>
<a id="adacf09dcab7be257dc2059148c2cdb99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adacf09dcab7be257dc2059148c2cdb99">&#9670;&nbsp;</a></span>reset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tes::PacketWriter::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="reference">References <a class="el" href="classtes_1_1PacketWriter.html#adacf09dcab7be257dc2059148c2cdb99">reset()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classtes_1_1PacketWriter.html#adacf09dcab7be257dc2059148c2cdb99">reset()</a>.</p>

</div>
</div>
<a id="ac1f56e63c059deec646d0e2ea2977bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f56e63c059deec646d0e2ea2977bf1">&#9670;&nbsp;</a></span>writeArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t tes::PacketWriter::writeArray </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elementSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elementCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an array of data items from the current position. </p>
<p>This makes the same assumptions as <code><a class="el" href="classtes_1_1PacketWriter.html#a67d88d43b9acc2bc84022bdbea155f1e" title="Writes a single data element from the current position. ">writeElement()</a></code> and performs an endian swap per array element. Elements in the array are assumed to be contiguous in both source and destination locations.</p>
<p>The writer position is advanced by the number of bytes write. Does not set the <code>Fail</code> bit on failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Location to write from. </td></tr>
    <tr><td class="paramname">elementSize</td><td>Size of a single array element to write. </td></tr>
    <tr><td class="paramname">elementCount</td><td>The number of elements to attempt to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success returns the number of elements written, not bytes. </dd></dl>

<p class="reference">Referenced by <a class="el" href="structtes_1_1ServerInfoMessage.html#a4e30e428594a6726ee79d96c36c8c127">tes::ServerInfoMessage::write()</a>, <a class="el" href="structtes_1_1ObjectAttributes.html#a41d09b339a65aea53415e71ee1734486">tes::ObjectAttributes::write()</a>, and <a class="el" href="classtes_1_1PacketWriter.html#a93fd2765dfdd18c3e2e182a8c35cbcc6">writeElement()</a>.</p>

</div>
</div>
<a id="a67d88d43b9acc2bc84022bdbea155f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d88d43b9acc2bc84022bdbea155f1e">&#9670;&nbsp;</a></span>writeElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t tes::PacketWriter::writeElement </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elementSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a single data element from the current position. </p>
<p>This assumes that a single data element of size <code>elementSize</code> is being write and may require an endian swap to the current platform endian.</p>
<p>The writer position is advanced by <code>elementSize</code>. Does not set the <code>Fail</code> bit on failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Location to write from. </td></tr>
    <tr><td class="paramname">elementSize</td><td>Size of the data item being write at <code>bytes</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>elementSize</code> on success, 0 otherwise. </dd></dl>

<p class="reference">Referenced by <a class="el" href="structtes_1_1MeshCreateMessage.html#a9f3cb9c073342ee502d0dee0c60b01d4">tes::MeshCreateMessage::write()</a>, <a class="el" href="structtes_1_1ServerInfoMessage.html#a4e30e428594a6726ee79d96c36c8c127">tes::ServerInfoMessage::write()</a>, <a class="el" href="structtes_1_1MeshDestroyMessage.html#a3775a56b885210e9bc9be562708c5f9e">tes::MeshDestroyMessage::write()</a>, <a class="el" href="structtes_1_1ControlMessage.html#af7e9a56bc46b9edb6db12bd74de5eda1">tes::ControlMessage::write()</a>, <a class="el" href="structtes_1_1MeshComponentMessage.html#a674434e81bee786d6ef7442683aedc6b">tes::MeshComponentMessage::write()</a>, <a class="el" href="structtes_1_1Material.html#a0bb7f6cca494f3923ea54d0cfc29e9d4">tes::Material::write()</a>, <a class="el" href="structtes_1_1CategoryNameMessage.html#ad5a5eb6a46b4c98cfbe929027b5462ff">tes::CategoryNameMessage::write()</a>, <a class="el" href="structtes_1_1MeshFinaliseMessage.html#a4178e043ad4ccfcd199353680729e054">tes::MeshFinaliseMessage::write()</a>, <a class="el" href="structtes_1_1CollatedPacketMessage.html#aa71fdd263bd1c8c0b02b00d0befe9e53">tes::CollatedPacketMessage::write()</a>, <a class="el" href="structtes_1_1ObjectAttributes.html#a41d09b339a65aea53415e71ee1734486">tes::ObjectAttributes::write()</a>, <a class="el" href="structtes_1_1CreateMessage.html#a8cac325ffce9fb25048516ea12b3a9ad">tes::CreateMessage::write()</a>, <a class="el" href="structtes_1_1DataMessage.html#a4571b0ae1c973f3fc7bae518313156fa">tes::DataMessage::write()</a>, <a class="el" href="structtes_1_1UpdateMessage.html#ac4d498fa88e2c88b50d1c801947b9ad0">tes::UpdateMessage::write()</a>, and <a class="el" href="structtes_1_1DestroyMessage.html#a6ac52a18dcc0f67ff040818d8d8c306c">tes::DestroyMessage::write()</a>.</p>

</div>
</div>
<a id="a93fd2765dfdd18c3e2e182a8c35cbcc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93fd2765dfdd18c3e2e182a8c35cbcc6">&#9670;&nbsp;</a></span>writeElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t tes::PacketWriter::writeElement </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a single data item from the packet. </p>
<p>This writes a number of bytes equal to <code>sizeof(T)</code> performing an endian swap if necessary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">element</td><td>Set to the data write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>sizeof(T)</code> on success, zero on failure. </dd></dl>

<p class="reference">References <a class="el" href="classtes_1_1PacketWriter.html#ac1f56e63c059deec646d0e2ea2977bf1">writeArray()</a>.</p>

</div>
</div>
<a id="a4cd9861810d73255c301e02181fcda0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd9861810d73255c301e02181fcda0c">&#9670;&nbsp;</a></span>writeRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t tes::PacketWriter::writeRaw </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>byteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes raw bytes from the packet at the current position up to <code>byteCount</code>. </p>
<p>No endian swap is performed on the data write.</p>
<p>The writer position is advanced by <code>byteCount</code>. Does not set the <code>Fail</code> bit on failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Location to write into.  byteCount Number of bytes to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes write. This may be less than <code>byteCount</code> if there are insufficient data available. </dd></dl>

<p class="reference">Referenced by <a class="el" href="structtes_1_1CategoryNameMessage.html#ad5a5eb6a46b4c98cfbe929027b5462ff">tes::CategoryNameMessage::write()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="3espacketwriter_8h_source.html">3espacketwriter.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetes.html">tes</a></li><li class="navelem"><a class="el" href="classtes_1_1PacketWriter.html">PacketWriter</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
