<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>3rd Eye Scene: tes::PacketWriter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">3rd Eye Scene</div>
   <div id="projectbrief">3rd Eye Scene documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classtes_1_1PacketWriter.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">tes::PacketWriter Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="tes::PacketWriter" --><!-- doxytag: inherits="PacketStream&lt; PacketHeader &gt;" -->
<p>A utility class for writing payload data to a <code><a class="el" href="structtes_1_1PacketHeader.html" title="The header for an incoming 3ES data packet.">PacketHeader</a></code>.  
 <a href="classtes_1_1PacketWriter.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="3espacketwriter_8h_source.html">3espacketwriter.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tes::PacketWriter:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classtes_1_1PacketWriter.png" usemap="#tes::PacketWriter_map" alt=""/>
  <map id="tes::PacketWriter_map" name="tes::PacketWriter_map">
<area href="classtes_1_1PacketStream.html" alt="tes::PacketStream&lt; PacketHeader &gt;" shape="rect" coords="0,0,215,24"/>
</map>
 </div></div>

<p><a href="classtes_1_1PacketWriter-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#ab18b3d8f42edba797b17b50f3577a791">PacketWriter</a> (<a class="el" href="structtes_1_1PacketHeader.html">PacketHeader</a> &amp;packet, uint16_t maxPayloadSize, uint16_t routingId=0, uint16_t messageId=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="classtes_1_1PacketWriter.html" title="A utility class for writing payload data to a PacketHeader.">PacketWriter</a></code> to write to the given <code>packet</code>.  <a href="#ab18b3d8f42edba797b17b50f3577a791"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#af2a4645e149622aef5cd9e6eaafb9e48">PacketWriter</a> (uint8_t *buffer, uint16_t bufferSize, uint16_t routingId=0, uint16_t messageId=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="classtes_1_1PacketWriter.html" title="A utility class for writing payload data to a PacketHeader.">PacketWriter</a></code> to write to the given byte buffer.  <a href="#af2a4645e149622aef5cd9e6eaafb9e48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#a871feef1eded8c54f334ede292da1729">PacketWriter</a> (const <a class="el" href="classtes_1_1PacketWriter.html">PacketWriter</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a871feef1eded8c54f334ede292da1729"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a610b3612c1d888e2ef344bf71b7d9b3f"></a><!-- doxytag: member="tes::PacketWriter::~PacketWriter" ref="a610b3612c1d888e2ef344bf71b7d9b3f" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#a610b3612c1d888e2ef344bf71b7d9b3f">~PacketWriter</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor, ensuring the CRC is calculated. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtes_1_1PacketWriter.html">PacketWriter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#a3d9205cb7bb4d151d238304f6b0bc006">operator=</a> (const <a class="el" href="classtes_1_1PacketWriter.html">PacketWriter</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a3d9205cb7bb4d151d238304f6b0bc006"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#a2403fbd4f2ef4853bfa9083f31b3386c">reset</a> (uint16_t routingId, uint16_t messageId)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the packet, clearing out all variable data including the payload, crc and routing id.  <a href="#a2403fbd4f2ef4853bfa9083f31b3386c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#adacf09dcab7be257dc2059148c2cdb99">reset</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf08e95affecbbdeb20d3894aadfa032"></a><!-- doxytag: member="tes::PacketWriter::setRoutingId" ref="acf08e95affecbbdeb20d3894aadfa032" args="(uint16_t routingId)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>setRoutingId</b> (uint16_t routingId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtes_1_1PacketHeader.html">PacketHeader</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#aa88278182924dbc82b9bdf2c6a4ded5a">packet</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the head of the packet buffer, for direct <code><a class="el" href="structtes_1_1PacketHeader.html" title="The header for an incoming 3ES data packet.">PacketHeader</a></code> access.  <a href="#aa88278182924dbc82b9bdf2c6a4ded5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30c855bfc8859aa7518933fabcfbb7e2"></a><!-- doxytag: member="tes::PacketWriter::data" ref="a30c855bfc8859aa7518933fabcfbb7e2" args="() const " -->
const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff7c84e4dc16b44ac38f5df36b19e3c5"></a><!-- doxytag: member="tes::PacketWriter::payload" ref="aff7c84e4dc16b44ac38f5df36b19e3c5" args="()" -->
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>payload</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79174d99e9466f4817ebf44199683039"></a><!-- doxytag: member="tes::PacketWriter::invalidateCrc" ref="a79174d99e9466f4817ebf44199683039" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>invalidateCrc</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#a81b4772101e8c074404052c17897fcd2">bytesRemaining</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes remaining available in the payload.  <a href="#a81b4772101e8c074404052c17897fcd2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#a28035c55f31e019b46d338e72ed3b8ef">maxPayloadSize</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the payload buffer.  <a href="#a28035c55f31e019b46d338e72ed3b8ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#af1cfacf0917a1392780302d5e3a1d4ca">finalise</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalises the packet for sending, calculating the CRC.  <a href="#af1cfacf0917a1392780302d5e3a1d4ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtes_1_1PacketStream.html#a86786079cd197b03966585a7cc0c9ffe">CrcType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#ab1b60dfd5fa3e1925f34db7d3573a866">calculateCrc</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the CRC and writes it to the <code><a class="el" href="structtes_1_1PacketHeader.html" title="The header for an incoming 3ES data packet.">PacketHeader</a></code> crc member.  <a href="#ab1b60dfd5fa3e1925f34db7d3573a866"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#a67d88d43b9acc2bc84022bdbea155f1e">writeElement</a> (const uint8_t *bytes, size_t elementSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a single data element from the current position.  <a href="#a67d88d43b9acc2bc84022bdbea155f1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#ac1f56e63c059deec646d0e2ea2977bf1">writeArray</a> (const uint8_t *bytes, size_t elementSize, size_t elementCount)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an array of data items from the current position.  <a href="#ac1f56e63c059deec646d0e2ea2977bf1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#a4cd9861810d73255c301e02181fcda0c">writeRaw</a> (const uint8_t *bytes, size_t byteCount)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes raw bytes from the packet at the current position up to <code>byteCount</code>.  <a href="#a4cd9861810d73255c301e02181fcda0c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtes_1_1PacketWriter.html#a91f6ea3f20e02c3de5fbfe5ee11eccf1">writeElement</a> (const T &amp;element)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a single data item from the packet.  <a href="#a91f6ea3f20e02c3de5fbfe5ee11eccf1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a92cfe8259348b8c8f24a17c78d1dde07"></a><!-- doxytag: member="tes::PacketWriter::writeArray" ref="a92cfe8259348b8c8f24a17c78d1dde07" args="(const T *elements, size_t elementCount)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>writeArray</b> (const T *elements, size_t elementCount)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a38bcefcd3d3c9be0906213be07be4147"></a><!-- doxytag: member="tes::PacketWriter::operator&gt;&gt;" ref="a38bcefcd3d3c9be0906213be07be4147" args="(T &amp;val)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtes_1_1PacketWriter.html">PacketWriter</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (T &amp;val)</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1dfd6daf615a5f1e0f17d3cc933835d3"></a><!-- doxytag: member="tes::PacketWriter::payloadWritePtr" ref="a1dfd6daf615a5f1e0f17d3cc933835d3" args="()" -->
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><b>payloadWritePtr</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7b30a0f5deb198e846725c70f98c512"></a><!-- doxytag: member="tes::PacketWriter::incrementPayloadSize" ref="ae7b30a0f5deb198e846725c70f98c512" args="(size_t inc)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>incrementPayloadSize</b> (size_t inc)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20ab3d567265f1d424df3b92c9208794"></a><!-- doxytag: member="tes::PacketWriter::_bufferSize" ref="a20ab3d567265f1d424df3b92c9208794" args="" -->
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>_bufferSize</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A utility class for writing payload data to a <code><a class="el" href="structtes_1_1PacketHeader.html" title="The header for an incoming 3ES data packet.">PacketHeader</a></code>. </p>
<p>This keeps the <code><a class="el" href="structtes_1_1PacketHeader.html" title="The header for an incoming 3ES data packet.">PacketHeader</a></code> <code>payloadSize</code> member up to date and ensures the CRC is calculated, either via <code><a class="el" href="classtes_1_1PacketWriter.html#ab1b60dfd5fa3e1925f34db7d3573a866" title="Calculates the CRC and writes it to the PacketHeader crc member.">calculateCrc()</a></code> explicitly on on destruction.</p>
<p>The payload buffer size must be specified in the constructor, and data writes are limited by this value. The packet is assumed to be structured such that the packet header is located at the start of the buffer, followed immediately by space for the payload.</p>
<p>Two construction options are available, one where the <code><a class="el" href="structtes_1_1PacketHeader.html" title="The header for an incoming 3ES data packet.">PacketHeader</a></code> details are already initialised, except for the <code>payloadSize</code> and <code>crc</code>. The given packet is assumed to be the start of the data buffer. The second constructor accepts a raw byte pointer, which marks the start of the buffer, and the size of the buffer. The buffer size must be large enough for the @ <a class="el" href="structtes_1_1PacketHeader.html" title="The header for an incoming 3ES data packet.">PacketHeader</a>. Remaining space is available for the payload.</p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000002">Bug:</a></b></dt><dd>Use the payloadOffset in various calculations hereing. It was added after this class was written, but is currently only supported as being zero, so it's not an issue yet. </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab18b3d8f42edba797b17b50f3577a791"></a><!-- doxytag: member="tes::PacketWriter::PacketWriter" ref="ab18b3d8f42edba797b17b50f3577a791" args="(PacketHeader &amp;packet, uint16_t maxPayloadSize, uint16_t routingId=0, uint16_t messageId=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tes::PacketWriter::PacketWriter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtes_1_1PacketHeader.html">PacketHeader</a> &amp;&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>maxPayloadSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>routingId</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>messageId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <code><a class="el" href="classtes_1_1PacketWriter.html" title="A utility class for writing payload data to a PacketHeader.">PacketWriter</a></code> to write to the given <code>packet</code>. </p>
<p>This marks the start of the packet buffer.</p>
<p>The packet members are initialised, but <code>payloadSize</code> and <code>crc</code> are left at zero to be calculated later. The <code>routingId</code> maybe given now or set with <code>setRoutingId()</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>The packet to write to. </td></tr>
    <tr><td class="paramname">maxPayloadSize</td><td>Specifies the space available for the payload (bytes). This is in excess of the packet size, not the total buffer size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2a4645e149622aef5cd9e6eaafb9e48"></a><!-- doxytag: member="tes::PacketWriter::PacketWriter" ref="af2a4645e149622aef5cd9e6eaafb9e48" args="(uint8_t *buffer, uint16_t bufferSize, uint16_t routingId=0, uint16_t messageId=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tes::PacketWriter::PacketWriter </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>routingId</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>messageId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <code><a class="el" href="classtes_1_1PacketWriter.html" title="A utility class for writing payload data to a PacketHeader.">PacketWriter</a></code> to write to the given byte buffer. </p>
<p>The buffer size must be at least <code>sizeof(PacketHeader)</code>, larger if any payload is required. If not, then the <code><a class="el" href="classtes_1_1PacketStream.html#ae4daabd28c6b84b5752f03d895c54cb2" title="Fail bit set?">isFail()</a></code> will be true and all write operations will fail.</p>
<p>The <code>routingId</code> maybe given now or set with <code>setRoutingId()</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The packet data buffer. </td></tr>
    <tr><td class="paramname">bufferSize</td><td>The total number of bytes available for the <code><a class="el" href="structtes_1_1PacketHeader.html" title="The header for an incoming 3ES data packet.">PacketHeader</a></code> and its paylaod. Must be at least <code>sizeof(PacketHeader)</code>, or all writing will fail. </td></tr>
    <tr><td class="paramname">routingId</td><td>Optionlly sets the <code>routingId</code> member of the packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a871feef1eded8c54f334ede292da1729"></a><!-- doxytag: member="tes::PacketWriter::PacketWriter" ref="a871feef1eded8c54f334ede292da1729" args="(const PacketWriter &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tes::PacketWriter::PacketWriter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtes_1_1PacketWriter.html">PacketWriter</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<p>Simple as neither writer owns the underlying memory. Both point to the same underlying memory, but only one should be used. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The packet to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a81b4772101e8c074404052c17897fcd2"></a><!-- doxytag: member="tes::PacketWriter::bytesRemaining" ref="a81b4772101e8c074404052c17897fcd2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t tes::PacketWriter::bytesRemaining </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of bytes remaining available in the payload. </p>
<p>This is calculated as the <code><a class="el" href="classtes_1_1PacketWriter.html#a28035c55f31e019b46d338e72ed3b8ef" title="Returns the size of the payload buffer.">maxPayloadSize()</a></code> - <code><a class="el" href="classtes_1_1PacketStream.html#aefbee5b6566eb585c4895e4f777de45a" title="Fetch the payload size bytes in local endian.">payloadSize()</a></code>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes remaining available for write. </dd></dl>

</div>
</div>
<a class="anchor" id="ab1b60dfd5fa3e1925f34db7d3573a866"></a><!-- doxytag: member="tes::PacketWriter::calculateCrc" ref="ab1b60dfd5fa3e1925f34db7d3573a866" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtes_1_1PacketStream.html#a86786079cd197b03966585a7cc0c9ffe">CrcType</a> tes::PacketWriter::calculateCrc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the CRC and writes it to the <code><a class="el" href="structtes_1_1PacketHeader.html" title="The header for an incoming 3ES data packet.">PacketHeader</a></code> crc member. </p>
<p>The current CRC value is returned when <code><a class="el" href="classtes_1_1PacketStream.html#ac6df312aac38e94dd1053beec3be7158" title="CRC validated?">isCrcValid()</a></code> is true. The CRC will not be calculate when <code><a class="el" href="classtes_1_1PacketStream.html#ae4daabd28c6b84b5752f03d895c54cb2" title="Fail bit set?">isFail()</a></code> is true and the result is undefined. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The Calculated CRC, or undifined when <code><a class="el" href="classtes_1_1PacketStream.html#ae4daabd28c6b84b5752f03d895c54cb2" title="Fail bit set?">isFail()</a></code>. </dd></dl>

</div>
</div>
<a class="anchor" id="af1cfacf0917a1392780302d5e3a1d4ca"></a><!-- doxytag: member="tes::PacketWriter::finalise" ref="af1cfacf0917a1392780302d5e3a1d4ca" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tes::PacketWriter::finalise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finalises the packet for sending, calculating the CRC. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the packet is valid and ready for sending. </dd></dl>

</div>
</div>
<a class="anchor" id="a28035c55f31e019b46d338e72ed3b8ef"></a><!-- doxytag: member="tes::PacketWriter::maxPayloadSize" ref="a28035c55f31e019b46d338e72ed3b8ef" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t tes::PacketWriter::maxPayloadSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the size of the payload buffer. </p>
<p>This is the maximum number of bytes which can be written to the payload. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The payload buffer size (bytes). </dd></dl>

</div>
</div>
<a class="anchor" id="a3d9205cb7bb4d151d238304f6b0bc006"></a><!-- doxytag: member="tes::PacketWriter::operator=" ref="a3d9205cb7bb4d151d238304f6b0bc006" args="(const PacketWriter &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtes_1_1PacketWriter.html">PacketWriter</a>&amp; tes::PacketWriter::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtes_1_1PacketWriter.html">PacketWriter</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator. </p>
<p>Simple as neither writer owns the underlying memory. Both point to the same underlying memory, but only one should be used. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The packet to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa88278182924dbc82b9bdf2c6a4ded5a"></a><!-- doxytag: member="tes::PacketWriter::packet" ref="aa88278182924dbc82b9bdf2c6a4ded5a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtes_1_1PacketHeader.html">PacketHeader</a> &amp; tes::PacketWriter::packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the head of the packet buffer, for direct <code><a class="el" href="structtes_1_1PacketHeader.html" title="The header for an incoming 3ES data packet.">PacketHeader</a></code> access. </p>
<p>Note: values are in network Endian. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A reference to the <code><a class="el" href="structtes_1_1PacketHeader.html" title="The header for an incoming 3ES data packet.">PacketHeader</a></code>. </dd></dl>

<p>Reimplemented from <a class="el" href="classtes_1_1PacketStream.html#a5511ffbb747a79f9c6ad6bd45262fb72">tes::PacketStream&lt; PacketHeader &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="adacf09dcab7be257dc2059148c2cdb99"></a><!-- doxytag: member="tes::PacketWriter::reset" ref="adacf09dcab7be257dc2059148c2cdb99" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tes::PacketWriter::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a2403fbd4f2ef4853bfa9083f31b3386c"></a><!-- doxytag: member="tes::PacketWriter::reset" ref="a2403fbd4f2ef4853bfa9083f31b3386c" args="(uint16_t routingId, uint16_t messageId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tes::PacketWriter::reset </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>routingId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>messageId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets the packet, clearing out all variable data including the payload, crc and routing id. </p>
<p>Allows preparation for writing new data to the same payload buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">routingId</td><td>Optional specification for the <code>routingId</code> after reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac1f56e63c059deec646d0e2ea2977bf1"></a><!-- doxytag: member="tes::PacketWriter::writeArray" ref="ac1f56e63c059deec646d0e2ea2977bf1" args="(const uint8_t *bytes, size_t elementSize, size_t elementCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t tes::PacketWriter::writeArray </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elementSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elementCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes an array of data items from the current position. </p>
<p>This makes the same assumptions as <code><a class="el" href="classtes_1_1PacketWriter.html#a67d88d43b9acc2bc84022bdbea155f1e" title="Writes a single data element from the current position.">writeElement()</a></code> and performs an endian swap per array element. Elements in the array are assumed to be contiguous in both source and destination locations.</p>
<p>The writer position is advanced by the number of bytes write. Does not set the <code>Fail</code> bit on failure.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Location to write from. </td></tr>
    <tr><td class="paramname">elementSize</td><td>Size of a single array element to write. </td></tr>
    <tr><td class="paramname">elementCount</td><td>The number of elements to attempt to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>On success returns the number of elements written, not bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a91f6ea3f20e02c3de5fbfe5ee11eccf1"></a><!-- doxytag: member="tes::PacketWriter::writeElement" ref="a91f6ea3f20e02c3de5fbfe5ee11eccf1" args="(const T &amp;element)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t tes::PacketWriter::writeElement </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a single data item from the packet. </p>
<p>This writes a number of bytes equal to <code>sizeof(T)</code> performing an endian swap if necessary. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">element</td><td>Set to the data write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>sizeof(T)</code> on success, zero on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a67d88d43b9acc2bc84022bdbea155f1e"></a><!-- doxytag: member="tes::PacketWriter::writeElement" ref="a67d88d43b9acc2bc84022bdbea155f1e" args="(const uint8_t *bytes, size_t elementSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t tes::PacketWriter::writeElement </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elementSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a single data element from the current position. </p>
<p>This assumes that a single data element of size <code>elementSize</code> is being write and may require an endian swap to the current platform endian.</p>
<p>The writer position is advanced by <code>elementSize</code>. Does not set the <code>Fail</code> bit on failure.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Location to write from. </td></tr>
    <tr><td class="paramname">elementSize</td><td>Size of the data item being write at <code>bytes</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>elementSize</code> on success, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a4cd9861810d73255c301e02181fcda0c"></a><!-- doxytag: member="tes::PacketWriter::writeRaw" ref="a4cd9861810d73255c301e02181fcda0c" args="(const uint8_t *bytes, size_t byteCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t tes::PacketWriter::writeRaw </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>byteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes raw bytes from the packet at the current position up to <code>byteCount</code>. </p>
<p>No endian swap is performed on the data write.</p>
<p>The writer position is advanced by <code>byteCount</code>. Does not set the <code>Fail</code> bit on failure.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Location to write into.  byteCount Number of bytes to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes write. This may be less than <code>byteCount</code> if there are insufficient data available. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="3espacketwriter_8h_source.html">3espacketwriter.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacetes.html">tes</a>      </li>
      <li class="navelem"><a class="el" href="classtes_1_1PacketWriter.html">PacketWriter</a>      </li>
      <li class="footer">Generated by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
